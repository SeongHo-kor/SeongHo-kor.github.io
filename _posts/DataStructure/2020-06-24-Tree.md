---
title : "DataStructure"
category :
    - DataStructure
tag :
    - Tree
author_profile : true
sidebar_main : true
use_math : true
headr:
    teaser : 
---

# Tree

### Tree에 대해 알아보자

1. Tree의 조건
- Tree는 하나의 Root 노드를 갖는다.
- Root노드는 0개 이상의 자식 노드로 구성되어 있다.
- 자식 노드 또한 0개 이상의 자식 노드를 갖고 있다.
- Cycle이 존재하지 않는다.


---


2. Tree의 종류

- Binary Tree : 각 노드가 최대 두개의 자식 노드를 갖는 트리
- Binary Search Tree : 왼쪽 자식 노드 <= 부모 노드 < 오른쪽 자식 노드를 만족하는 트리
- Balance Binary Tree vs Unblance Binary Tree
    - insert,find를 할 수 있는 시간 O(logN)가 걸리는 트리 -> Balance Binary Tree
    - 부모 노드의 왼쪽 또는 오른쪽 노드로 한쪽으로 치우친 트리 -> Unblance Binary Tree
- Complete Binary Tree: 노드가 꽉 차있는 Binary Tree, 마지막 Level의 노드는 왼쪽만 채워져도 가능한 트리.
- Full Binary Tree: 모든 노드가 자식 노드이 없거나 모두 두개의 자식 노드를 갖는 트리.
- Perfect Binary Tree: (Complete + Full) binary tree, 마지막 Lvel의 노드 개수가 최대.


---


3. Tree 구현

- Min_Heap 구현

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void swap(int *lhs, int* rhs) {
	int temp = *lhs;
	*lhs = *rhs;
	*rhs = temp;
}

int get_parent(int child) {
	return ((child % 2) == 0) ? (child - 1) / 2 : (child / 2);
}

void sift_down(int* arr, int current, int last) {

	int left;
	int right;
	int max;

	while ((current * 2) + 1 <= last) {
		left = (current * 2) + 1;
		right = (current * 2) + 2;
		max = current;

		if (arr[left] > arr[max]) {
			max = left;
		}

		if (right <= last && arr[right] > arr[max]) {
			max = right;
		}

		if (max != current) {
			swap(&arr[current], &arr[max]);
			current = max;
		}
		else {
			return;
		}
	}
}

void sift_up(int* arr, int root, int current) {

	int parent;

	while (current > root) {
		parent = get_parent(current);
		if (arr[parent] >= arr[current])
			return;

		swap(&arr[parent], &arr[current]);
		current = parent;
	}
}

void heapify_top_down(int* arr, int length) {

	int end = 1;

	while (end < length) {
		sift_up(arr, 0, end++);
	}
}

void heapify_buttom_up(int* arr, int length) {

	int end = length - 1;
	int current = get_parent(end);

	while (current >= 0) {
		sift_down(arr, current--, end);
	}
}

void heap_sort(int* arr, int length) {
	if (arr == nullptr || length <= 1) {
		return;
	}

	// heapify
	// heapify_top_down(arr, length);
	heapify_buttom_up(arr, length);

	// sort
	int end = length - 1;
	while (end > 0) {
		swap(&arr[0], &arr[end--]);
		sift_down(arr, 0, end);
	}
}


void make_test_array(int* arr, int length, int max) {
	if (arr == nullptr || length <= 1) {
		return;
	}

	srand((unsigned int)time(NULL));
	for (int i = 0; i < length; i++) {
		arr[i] = rand() % max;
	}
}

bool is_sorted_array(int* arr, int length) {
	if (arr == nullptr || length < 1) {
		return false;
	}

	for (int i = 0; i < length - 1; i++) {
		if (arr[i] > arr[i + 1])
			return false;
	}

	return true;
}

int main(int argc, char *argv[])
{
	int size = 1000;
	int* arr = new int[size];

	make_test_array(arr, size, size * 2);
	std::cout << is_sorted_array(arr, size) << std::endl;
	heap_sort(arr, size);
	std::cout << is_sorted_array(arr, size) << std::endl;

	delete[]arr;
	return 0;
}

```

